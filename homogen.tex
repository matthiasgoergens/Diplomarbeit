% Plan: Beispiel und Allgemeines in Einleitung trennen.

\documentclass[a4paper]{amsart}
\usepackage{a4}
\usepackage{charter}

% \usepackage[fulladjust]{marginnote}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{units}
\usepackage{amsmath}
%\usepackage{pdfsync} % does not seem to work currently.

\newtheorem{theorem}{Theorem}

\theoremstyle{definition}
\newtheorem{defn}[theorem]{Definition}


\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\author{Matthias Görgens}

% ---- LATIN ----
\def\etal{\emph{et~al.}}
\def\ie{\emph{i.e.}}
\def\Ie{\emph{I.e.}}
\def\eg{\emph{e.g.}}
\def\vitae{vit\ae{}}
\def\apriori{\emph{a~priori}}
\def\aposteriori{\emph{a~posteriori}}

% ---- FRENCH ----
\def\naive{na\"{\i}ve}
\def\Naive{Na\"{\i}ve}
\def\naively{na\"{\i}vely}	% Okay, I know, this isn't French.
\def\Naively{Na\"{\i}vely}


% Other
\def\Cpp{C\raisebox{0.5ex}{\tiny\bf++}}

%\todo does not work in the abstract.

\newcommand{\ol}[1]{\overline{#1}}


\newcommand\mpar[1]{\marginpar {\flushleft\sffamily\small #1}}
\setlength{\marginparwidth}{3cm}
\setlength{\marginparpush}{1cm}

\newcounter{todo}
\newcommand{\todo}[1]{\({}^{\text{{\arabic{todo}}}}\) \mpar{todo \arabic{todo}: #1} \addtocounter{todo}{1}}
\newcommand{\redo}[1]{\({}^{\text{{\arabic{todo}}}}\) \mpar{remark \arabic{todo}: #1} \addtocounter{todo}{1}}
%\newcommand{\todo}[1]{\footnote{#1}}

\DeclareMathOperator{\In}{in}
\DeclareMathOperator{\Out}{out}

%für ein/aus-gehende kanten
\newcommand{\ina}{\ensuremath{\vec{\In}}}
\newcommand{\outa}{\ensuremath{\vec{\Out}}}

%für knoten ein/aus-gehender kanten.
\newcommand{\inv}{\ensuremath{\dot{\In}}}
\newcommand{\outv}{\ensuremath{\dot{\Out}}}

\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\newcommand{\naturals}{\ensuremath{\mathbb{N}}}
\newcommand{\integers}{\ensuremath{\mathbb{Z}}}
\newcommand{\rationals}{\ensuremath{\mathbb{Q}}}

\newcommand{\Hom}{\ensuremath{\mathrm{Hom}}}
\newcommand{\Sym}{\ensuremath{\mathfrak{S}}}

\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
% lr := left right
\newcommand{\lr}[1]{\ensuremath{\left( #1 \right)}}
% lrX := left right für spitze Klammern
\newcommand{\lrX}[1]{\ensuremath{\left< #1 \right>}}
% lrM := left right für Mengen
\newcommand{\lrM}[1]{\ensuremath{\left\{ #1 \right\}}}

\usepackage{hyperref}
\begin{document}

\date{\today}
\title{Homogeneous vehicle schedules}

\begin{abstract}
  Although most railroad timetables remain in use for half a year,
  they tend to repeat each week.  Thus one can also repeat
  their implementations in rolling stock, the vehicle schedulings,
  each week.  %\todo{Is this always the most efficient think to do?}

  But timetables tend to show even more structure: All the working
  days of the week are usually identical.  This work sets out to
  investigate how to preserve this similarity in vehicle schedules in
  a linear integer model.  We define these schedules as
  \textit{homogeneous} vehicle schedules, establish a measure of
  partial homogeneity and search for ways to efficiently find the most
  homogeneous vehicle scheduling for a given timetable.
\end{abstract}

\maketitle
\tableofcontents
%\todo{unterschied zwischen fahrplan und umlaufplan im abstract ausarbeiten.}

\section{Introduction}
Unlike individual traffic in cars, railroads in Germany are run by
only a few companies and of those Deutsche Bahn (and its subsidaries)
control a huge majority.  In principle the planning required can be
centralized for coördination.  Thus one can exploit effects of synergy
at the cost of central information gathering and efforts of
computation.  Even relatively modest relative improvements can have a
huge absolute impact.  So it is worthwhile to solve the encountered
problems to optimality.

One large block---or even the largest---of opportunities for
mathematical planning in this contexts lies in the area of scheduling
locomotives.  Currently at Deutsche Bahn the system for planning
schedules is multi-tiered.  This paper has been written while working
at department GSU1 of DB Mobility Logistics.  The focus at GSU1 is on
improving the process of (strategic) vehicle schedulings.

\todo{unterschied zwischen fahrplan und umlaufplan im abstract ausarbeiten.}
\todo{Mit Hanno besprochen: 
  - darstellung der legacy anwendung (blockdarstellung:
  di,mi,do als einen tag planen, ausnahmen einfuegen, rest der woche einfuegen)
  - Morphism between torus (=tagesplaene) und umlaufkettendarstellung.
  und aufweichen der homogen.-bedingung durch trennen von zuegen.
  - herleitung der homogenitaetsbedingung
}

As a customer one only sees the timetables, that specify when and
where a train will arrive and depart to take on or load off cargo or
passengers.  One does not care too much which specific physicial train
one is using or what it does before and after the trip.

Naturally the railroad company---in contrast---does care about what
happens to a train after it finishes a trip.  Normally it goes on to
provide another trip to paying customers.  From time to time there
will also be maintenance stops or trips to another station without
moving freight or passengers.

We will only be concerned with strategic planning, that is with the
connection between trips on a regular schedule planned in advance.  In
the field the best laid plans often need patching on the fly, because
of unforeseen circumstances like accidents, faults or labor strikes.
An activity called operational planning and outside the scope of this
work.  Also we will view the timetables of trips offered to the
customers as fixed parameters to reflect the conditions encountered at
GSU1: Another department decides about the timetables.  Also we won't
care how to transition between different schedules; we will view a
schedule as valid forever.  In practise the problem of transition
arises at least once twice a year, Since most timetables are in use
for half a year.  They tend to repeat every week.  At the current
state of the art, strategic vehicle schedule planning ignores the
start and end of the period and pretends to work on an infinite cycle
of identical weeks.  This rolls up a long schedule to a more tractable
cycle of just one week.

\redo{Ein abregenzendes Wort zu timetable und operationeller Planung
  im Vergleich?  Vielleicht reicht das jetzt schon so.}

Introducing our first bit of notation we call trips offered to the
customer \textit{service trips} (\textit{Nutzfahrten} in German) and
other trips will be called \textit{deadhead trips}
(\textit{Leerfahrten} in German).  Deadhead trips may be necessary
because a the numbers of service trips departing from and arriving at
station may differ over the course of a week.  Or the number is equal,
and the station could keep the balance in theory, but only with long
unproductive standing times for the trains.  Say, a station with its
only departure on Monday morning and only arrival later that day.

The objective of strategic planning is to reduce the cost of
implementing a fixed timetable.  The number of locomotives needed
contributes the biggest chunk to those costs.  Avoiding deadhead trips
also saves some money, as they cost man-hours, fuel, and bring the
next obligatory maintenance closer.  Because most types of maintenance
aren't scheduled in fixed time intervals, but after certain distances
travelled.  \redo{Mention hauling (\textit{Schleppen})?}

Strategic vehicle schedule planning in essence takes in cyclic
timetables (plus possible non-cyclic extra trips) and puts out vehicle
schedules to the operational planners, who \eg{} manage the transition
between schedules \redo{Hanno, stimmt das?} or short-term challenges like
accidents.

Deutsche Bahn has only recently brought sophisticated math to bear on
strategic vehicle scheduling.  There are legacy heuristics in place
that solved (and do solve) scheduling problems, but with no guarantees
of optimality.  Also customs and preferences have developed.

For example planners prefer their schedule to be as homogenous as
possible.  Because this is what they got by default with the old
methods, and thus a certain sense of simplicity and \ae{}sthetics has
developed.  We will talk a lot about homogeneity, so we start with an
example before giving a rigorous definition.  Typically, in freight
logistics for example, a huge part of all trips repeats with the same
time and route every Tuesday, Wednesday and Thursday.  So these three
days get scheduled as one cycling day, and this is where the
homogeneity comes from.  To produce a working schedule, this single
day cycle is then unrolled to a three-day cycle, and the planners add
the other trips occurring in the middle of the week.  Finally the
three-day-cycle is `cut' on the transition of Thursday to Tuesday, and
the other four days of the week and their trips are inserted. 

To make the schedule usable, one has to answer further questions, like
how to deal with trips that do not repeat every week.  And how to
change from one schedule to another.  But these are beyond the scope
of this stage of planning at Deutsche Bahn, and beyond the scope of
this work.

At each step the above, where new trips are inserted into the
proto-schedule, the old trips can get re-scheduled, if this makes the
schedule cheaper to implement.  But planners tend to avoid those
changes when possible.

The new methods based on mixed integer programming consider the whole
week right from the start.  Apart from the partly repeating timetable
they have no reason to use similar vehicle schedulings on the working
days.  But planners have come to price the homogeneity as an end in
itself, because their preferred visualization of schedules looks more
pleasing in the presence of homogeneity.  \todo{Hanno, stimmt der Grund so?}
\todo{Add more about blocks. Visualization.}

\todo{Noch mehr Grundlagen.  Ausführungen zu Betriebsablauf bei der
  Bahn.}

\section{Thanks}
Thanks to Hanno Schülldorf, Volker Kaibel and Andreas Huck for their
help.  \redo{Noch ein paar mehr Leute aufführen.}

\section{Some definitions}

\todo{Noch mehr mathematische Grundlagen?  Column and Row generation? Ja, ist aber eher Füllmaterial.}

\todo{Hanno schlägt vor, Beispiel (Woche = 7 Tage) und allgemeine
  Theorie zu trennen.
  Alternativer Plan: Nutze Woche als technischen Term (so wie Byte),
  und lege erst später fest, dass \(w := 7\).  Verwirrt aber u.U. zu
  sehr.  Könnte aber mit einem Term wie `cyclic period' (oder so) funktionieren.}

\subsection{Timetables}

Let \(V\) be the set of all stations \eg{} ordinary railway stations,
maintenances shops.  The rail network of connected stations will be
modelled as a directed graph \(G = (V,A)\), where \(A \subseteq V \to V\).
A \label{trip} \textit{trip} starting in one station \(v \in V\) and ending in another
station \(w \in V\) can be characterized by a tuple \((v, t_v, w, t_w)
\in \left(V \times \rationals\right)^2 \),
where \(t_v\) and \(t_w\) are the departure and arrival times.
\newcommand\dep[0]{\ensuremath{\operatorname{dep}}}
\newcommand\arr[0]{\ensuremath{\operatorname{arr}}}
\begin{defn}[Departure and Arrivals]
  \begin{align*}
    \dep, \arr \colon & \lr{V \times \rationals}^2 \to \lr{V \times \rationals} \\
    & x = \lr{\dep \lr{x}, \arr \lr{x}}
  \end{align*}
\end{defn}
We call a set of trips \(T \subseteq \left(V \times
  \rationals\right)^2\) a timetable.  (In practise \(T\) may also be a
multiset and may carry more information, like the type of locomotives
allowed for this trip.)

We want to focus our attention on cyclic timetables.
\begin{defn} A timetable \(T\) is \label{cyclic} \textit{cyclic}, iff
  there exists a period \(w \in \rationals^+\), so that for each trip
  \((v, t_v, w, t_w) \in T\) the trips \(\{(v, t_v+n w, w, t_w +n w)
  \mid n \in \mathbb{Z}\}\) are also in \(T\).
\end{defn}
We will assume that no trip takes longer than one cycle and
we will identify cyclic timetables with their image under the canonic
morphism
\[\left(V \times \rationals\right)^2 \to
\left(V \times \rationals/{\left(w \integers\right)}\right)^2\text{.}\]

\subsection{The matching model for schedules}

A timetable only fixes the service trips offered by the rail operator.  But
it does not specify where the locomotives and cars in use come from or
where they go afterwards.  Naturally one wants to re-use rolling stock
from one trip for another one.  So one seeks to match arrivals from
one trip with following departures from another trip.

\begin{defn}[Matching formulation]
  Given a timetable \(T \subseteq \left(V \times
    \rationals\right)^2\), a perfect matching \(M \subseteq \arr \lr{T} \times \dep \lr{T}\)
  describes a schedule to implement \(T\) using the matching formulation.
\end{defn}
\begin{defn}[Chains-of-trip formulation]
  Given a timetable \(T \subseteq \left(V \times \rationals\right)^2\)
  and a schedule in matching formulation \(M \subseteq \arr \lr{T}
  \times \dep \lr{T}\) that implements it,
  define the chains-of-trip formulation \(C \in \Sym\lr{T}\)\footnote{where \(\Sym \lr{T}\) is the symmetric group over \(T\)} of that schedule as follows:
  \[C \lr{x} = y\text{, iff }\lr{\arr\lr{x},\dep\lr{y}} \in M\text{.}\]
  This can also be viewed as a \(\lrM{0,1}\)-network-circulation.
\end{defn}

The two formulations above are equivalent if all times are distinct.
If necessary extending the definitions to include unique labels for
all trips (and their departures and arrivals) preserves this property
for all cases.  But we want to keep the presentation simple.

\subsection{Costs}

Not all schedules are equal.  In general different schedules implement
a given timetable at different costs.  One component of the costs is
proportional to number and time each locomotive is in us (\eg{}
interest on capital, deprecation charges).  The other component is
caused primarily by the distance travelled by each locomotive, mainly
because this burns fuel and causes wear; maintenance stops are
scheduled after fixed intervals of distances travelled, and thus
accounted for.  Man-hours for the locomotive
drivers are a special case, because they only occur while travelling a
distance, but are proportional to the time this takes.

Of course the service trips in our timetable also cause costs.  But
they are the same for every schedule, so we can ignore them, since we
are only interested in differences between schedules.  The schedule
can include other so called deadhead trips, if it matches an arrival
at one station with a departure from a different station.

All in all we can satisfy those requirements by assigning a specific
cost to every edge of the matching graph, and sum the costs of the
edges used:
\begin{defn}[Costs in the matching model]
  Given a cost vector \(c \in \rationals^{\arr \lr{T} \times \dep\lr{T}}\) the cost \(C\) of a schedule \(M\) is:
  \[C \lr{M} := \sum_{x \in M} c \lr{x}\]
\end{defn}

\begin{remark}
  There is an alternative, but equal, formulation in use at Deutsche
  Bahn that allocates the components of the costs that are
  proportional to the time the locomotives are in use, not to each
  match or trip, but only to the matches and trips that span a
  specific point in time of the cycle (\eg{} Sunday, 24.00), the so
  called \textit{cycle jump}\redo{Hanno, ist period jump eine
    vernünftige Übersetzung für Periodensprung?}.  This works because
  we can view the scheduling as a network circulation problem, where
  flow is preserved, on a graph that is embedded in a circle of
  time. \todo{How about adding a more formal proof here?}  \Ie{} the
  flow is constant at every instant in time, because every moment is a
  cut \todo{Ist cut richtig?  Ist ja kein S-T-Schnitt, sondern das
    Auftrennen eines Tori.} in the graph.

  This allocation concentrates costs on matches spanning the period
  jump and on the deadhead trips \todo{Die deadhead trips müssen immer
    noch einzeln behandelt werden?}, leaving most matches without
  associated costs.  Some times this makes \textsc{Cplex} solve the
  problem faster.
\end{remark}

\subsection{The block formulation gives rise to homogeneity}
\todo{Homogenität kann (immer) hergestellt werden durch Teilen von
  Zügen.  (Minimiere diese Zahl, wenn nötig.)  Einfacher zu
  handhaben als abweichende Wenden.}

\todo{Mit anderen Abschnitten zusammenführen.}

At Deutsche Bahn another approach is also in use.  It stems from the
desire to visualize timetables and schedules and is the traditional
formulation.  This approach, called the block formulation, naturally
leads to homogeneity.

The visualization of the block formulation displays the vehicle
schedulings as a two-dimensional table.  From left to right (and then
logically wrapping around to the left again) runs the time-axis, with
columns for the days of the week (\textit{Verkehrstage} in German) and
inside each column the time of the day.  Each service trip is an
interval on this axis.  From top to bottom the diagram is split into
an integral number of virtual days (\textit{Umlauftage} in German).
Several virtual days make up a cycle, and there are in general more
than one of those cycles per vehicle scheduling.  The virtual days are
basically used to give different trips on the same weekday different
coördinates.  One can view each part of the table that consists of a
single cycle of virtual days, as a torus, because it logically wraps
around on both axes.

Exactly one locomotive makes all service trips on a given pair of
weekday and virtual day.  On the next weekday each locomotive goes on
to the next virtual day in its cycle.  Thus trips that can't be done
by one locomotive, \eg{} because they overlap in time, can not share
the same coördinates.  They need to differ in their virtual day.

\redo{Why do they not jump to the next virtual day only at the end of
  a week?  Hanno says in freight they do.  Pros and Cons?  In the end
  we take this requirement from practise and do not question it.}

Just like each trip gets repeated every week, the schedule of a single
locomotive repeats every \(\operatorname{lcm} \lr{w, u}\) days, where
\(w\) is the number of days in a week and \(u\) is the length of the
cycle of virtual days of this locomotive.

Only tori where every locomotive visits combination of weekday and
virtual day, that is \(\gcd{} \lr{w,u} = 1\), are considered proper in
the existing literature at Deutsche Bahn.  But we will extend the
notion to tori partitioned into more than one orbit.

\begin{defn}[Block Formulation]
  The block formulation can be formalized as a sequence \(U_i = \integers / \lr{l\lr{i} \integers}\) of
  cycles of virtual days with length \(l \colon \naturals \to \naturals\).  And a mapping \(a\) that
  assigns each service trip to a virtual day in the cycles:
  \[a \colon T \to \bigcup_{i \in \naturals} \lrM{i} \times U_i\]
  Service trips that overlap in time can not be part of the same
  virtual day.  We can further demand \(l\) to be antitonic.
  \todo{Und Verkehrstag ist u.U. nicht genau festgelegt, wenn Fahrten
    über Mitternacht gehen.}
\end{defn}

A schedule is said to be homogeneous if for any given train all its
trips happen on the same virtual day.  If homogeneity causes more
locomotives to be used than optimal, the planners violate it in two
different ways: Trains are split up into different virtual days, and
locomotives may continue to a virtual day that is different from the
`next' in the cycle.  (This is called \textit{abweichende Wenden} in
German.  The normal continuation on the next virtual day are called
\textit{logische Wenden}.)

\subsection{A morphism between the matching formulation and the block formulation}

How can we transform the assignment \(a\) (and lengths of cycles
\(l\)) of the block formulation into the perfect matching \(M\) of the
matching formulation, and vice versa?

First the easy direction: Given \(a\) and \(l\).  Given two service
trips \(v, w \in T\), and the sets \[v^> := \lrM{x \in T \mid a\lr{x}
  = a\lr{v}, \dep\lr{x} > \dep\lr{v}}\] and
 \[w^< := \lrM{x \in T \mid
  a\lr{x} = a\lr{w}, \dep\lr{x} < \dep\lr{w}}\text{,}\] the match
\(\lr{\arr\lr{v}, \dep\lr{w}}\) will be in included in the matching
\(M\) if and only if
\begin{itemize}
\item the service trips are on the same virtual day \(a \lr{v} = a \lr{w}\) and there is no service trip between them \ie{}
  \(v^> \cap w^< = \emptyset\)
\item \textsc{or} \(v\) and \(w\) are the latest respective first service trip in their virtual days (\(v^> = \emptyset\) and \(w^< = \emptyset\))
  and
  \begin{itemize}
  \item \(v\) and \(w\) are on consecutive virtual days (\(\lr{i, u} := a\lr{v}\) and \(\lr{i, u+1} = a\lr{w}\))
  \item and also on consecutive weekdays (\(\left\lfloor \dep\lr{v}\right\rfloor + 1 = \left\lfloor \dep\lr{w}\right\rfloor \))
  \end{itemize}
\end{itemize}

The other direction is slightly more complicated.  Given \(M\).  Start
with any service trip \(v \in T\) and a count of cycles \(i := 0\).  Assign \(a\lr{v} = \lr{0,0}\).
Continue with the trip \(w \in T\) whose departure is matched to
\(v\)'s arrival.  Consider two cases:
\begin{itemize}
  \item If \(w\) has not been assigned a virtual day, yet, then assign \(a\lr{w} := a\lr{v} + \left\lfloor \dep\lr{w}\right\rfloor - \left\lfloor \dep\lr{v}\right\rfloor \).  Continue with the successor of \(w\).
  \item If \(w\) has already been assigned a virtual day, then assign
    \(l\lr{i} = a\lr{w} + 1\).  Continue with a new index \(i' = i+1\)
    and a new service trip, if there are any left.
\end{itemize}

After this procedure we may be able to merge cycles of virtual days.
This may be the case if \(\gcd \lr{w, l\lr{i}} > 1\).  Where \(w\) is
the number of days in the week.  (When you display the block
formulation in a table, then there will be empty diagonals in this
case.)

Two merge two cycles \(U_i, U_j\) in one table \(U_{\lrM{i,j}} \), we
check if there is an offset \(o \in \integers\) so that
\[\lr{a \mid t \in T, a\lr{t} = \lr{i,x}} \cap \lr{a \mid blabla} = \emptyset\]

\[
%pairwise (disjunct `on` fn (i) -> \cap (map (+(0,o_i) . coordinates) . filter ((\in U_i) . days) \$ trips)) merge-candidates 
\] % -> notation finden!

\todo{Continue with Merging.  Orbits and Nebenklassen.}
      

\subsection{Homogeneity in the matching model}

\todo{Züge should be introduced earlier, so that the section above can reference them.}

In practise timetables repeat every week \ie{} \(w = 7 \textrm{ days}\).
This work will deal with timetables that show more structure: Fix an
interval \(d := \frac{w}{n}\) with \(n \in \naturals^+\) (\eg{} for
days in a week, let \(n=7\)).  We partition the trains into
equivalence classes that share the same arrival and departure
stations, and whose arrival and departure times only differ by an
integral multiply of \(w\) (\ie{} whole days):
\begin{equation}
  \left[\left( v, t_v, w, t_w \right) \right]_d := \{(v, t_v+n d, w, t_w +n d) \mid n \in \mathbb{Z}\}
\end{equation}
Let \(C\) be the set of all those classes.

Ideally each class has exactly one member for each day of the week.
That would allow \(w = 1 \textrm{ day}\) instead of \(w = 7 \textrm{ days}\)
and enable a schedule that repeats perfectly every day.  But more
typical we observe a lot of classes in a timetable with one member
each day from Monday to Friday and none on the weekends.  Or even less
regular arrangements.

We will define a distance function \(\Delta_S (s,t)\) on paths in
\(S\) as the sum of arc lengths \(d\) in the path between the
trains \(s\) and \(t\) or \(\infty\) if no such path exists.  We can
talk about \emph{the} path \(P \subseteq S\) between \(s\) and \(t\),
because \(G_S\) consists only of disjoint cycles.
\[\Delta_{S}\colon T \times T \to \rationals^+_0 \cup \{\infty\}\]
\begin{equation}
\label{defDelta}
\Delta_S (s,t) = \begin{cases}
\sum_{(v,w)\in P} d(v,w) & \textrm{if there is a path \( P \in S\) between \(s\) and \(t\)}\\
\infty & \textrm{else}
\end{cases}
\end{equation}

\todo{Bezeichnungen!  Pfeile über t?}

\todo{Mehrwöchige Fahrten: Zurückgehen auf die ursprüngliche
  nicht-zyklische Version!  Oder einfach als außerhalb des Scopes
  definieren.}

Of course we have only moved the problem.  We still have to define the
length of a single arc: \(d(t, \ol{t})\) shall be the minimal time
that a vehicle needs to provide \(t\) and be ready for the departure
of \(\ol{t}\):
\[
d ((\cdot, t_{\textrm{dep}}, \cdot, t_{\textrm{arr}}), (\cdot, \ol{t_{\textrm{dep}}},\cdot, \cdot)  :=
\min (\{\ol{t_{\textrm{dep}}} - t_{\textrm{dep}} + n w \mid \ol{t_{\textrm{dep}}} - t_{\textrm{arr}} + nw \geq 0, n \in \mathbb{Z}\} \cap \rationals^+_0)
\]

In most cases this will be just the difference \(\ol{t_{\textrm{dep}}}
- t_{\textrm{dep}}\), but we may need to add a whole number of weeks
if \(\ol{t}\) departs before \{t\} arrives.  Also a more general approach
has to be taken when trains take more than one week from arrival to
departure.

To guarantee homogeneity one might \naively{} propose that all members
of one class~\(c_1\) only be succeeded by members of the same class~
\(c_2\).  But that would not be practial, because \eg{} a class that
is offered all week would be banned from being connected to a class of
trains that are not offered on the weekend.

So we introduce a weaker condition.  A schedule \(S\) is called
homogeneous iff:
\begin{defn} Given
  \begin{itemize}
  \item classes \(z, \ol{z} \in C\)
  \item and trains \(r_1, r_2 \in z\) and \(\ol{r}_1,\ol{r}_2 \in \ol{z}\)
  \item with \( d (r_1, r_2) = d(\ol{r}_1, \ol{r}_2) \),
\end{itemize}
  then either there is no path between neither \(r_1\) and
    \(\ol{r}_2\) nor \(r_2\) and \(\ol{r}_2\) in \(S\); or they are connected by paths of the same length:
    \begin{equation}
      \label{homoEq}
      \Delta_S (r_1, \ol{r_1}) = \Delta_S (r_2, \ol{r_2})\textrm{.}
    \end{equation}
\end{defn}

\begin{defn}
For arcs in a digraph \(G=(V,A)\) we will use the following notation:
\begin{align*}
\ina\colon  V &\to \mathcal{P}(A) \\
v &\mapsto \left(V \times \{v\}\right) \cap A\\
%\end{align*}
%\begin{align*}
\outa\colon  V &\to \mathcal{P}(A) \\
v &\mapsto \left(\{v\} \times V\right) \cap A\\
%\end{align*}
%\begin{align*}
\inv\colon  V &\to \mathcal{P}(V) \\
v &\mapsto \left\{ u \colon \left(u,v\right) \in \ina(v) \right\}\\
%\end{align*}
%\begin{align*}
\outv\colon  V &\to \mathcal{P}(V) \\
v &\mapsto \left\{w \colon \left(v,w\right) \in \outa\left(v\right) \right\}\\
\end{align*}s
\end{defn}

\section{An infinite integer linear program}
\label{infIP}

Let \(T\) be a timetable.  And let \(G_\mathbb{S} := (T, \mathbb{S} =
T \times T) \) be its associated complete graph.  A schedule \(G_S =
(T, S \subseteq \mathbb{S})\) will be a subgraph of \(G_\mathbb{S}\).


For the integer program we introduce the variable \(m\) with the
following domain and interpretation:
\begin{align}
  m & \colon T \times T \to \{0,1\} \\
  m & \cong \mathbf{1}_{S}
\end{align}
Where \(\cong\) means ``defined as'' or ``to be interpreted as''.

The following two equations capture the requirement that \(G_S\)
consists of disjoint cycles.  For all \(r \in T\):
\begin{align}
  \label{matchBedingung}
  \sum_{a \in \ina(r)}  m(a) = \sum_{a \in \outa(r)} m(a) = 1
\end{align}

To reflect the values of \(\Delta_S\) in the integer program we use the binary variables \(\delta\):
\begin{align}
  \delta \colon T \times T \times \rationals & \to \{0,1\} \\
  \delta\left(r, q, \Delta_S\left(r,q\right)\right) &\cong 1 \\
  \label{onlyOne}
  \sum_{z \in \rationals} \delta(r, q, z) &\leq 1
\end{align}

For every simple path \(P \subseteq \mathbb{S}\) that starts in \(r\) and ends in \(q\) we have:
\begin{align}
\label{zwingHoch}
\sum_{a \in P} (m(a) - 1) \leq \delta \left(r,q, \sum_{a \in P} d \left(a\right)\right) - 1 \textrm{;}
\end{align}
\ie{} if \(P \subseteq S\) then length of \(P\) gives
the distance between its endpoints in \(S\).

And for every \(r\)-\(q\)-cut \(C \subseteq T\) (with \(r \in C\)):
\begin{align}
\label{zwingRunter}
  \sum_{a \in C \times (T \setminus C)} m(a) \geq \sum_{z \in \rationals} \delta (r,q, z)
\end{align}

% \(G_S=(T,S\subseteq T^2)\)


% Aufbau: Modell oder Anwendung?
% Anwendung: Umlaufplanung etc, Abschätzung anderer Möglichkeiten.  Anwendung zur Motivation.
% Welcher Umfang zur Anwendung?  Literatur.  Allgemeine Beschreibung?  Irgendeine Referenz wird es schon geben.

% relation durch Übersetzung von Nutzfahrt ersetzen.

\todo{welche constraints?  labels und refs.  convex set vs gitterpunkte?}
Those constraints define a convex set.  Alas we can't use them
directly, since there are an infinite number of constraints.  But
fortunately they are constructed for use with row generation.  We will
show that there is a finite subset of constraints that define the same
polytope.  And we will show how to define a polynomial oracle to find
violated constraints.

Now we only have defined a way to measure time-distances in the
vehicle schedule in a linear integer program.  We still have to
incorporate the actual homogeneity constraints laid out in equation
\ref{homoEq}.  But this is simple as we only have to convert
equation \ref{homoEq} from using \(\ol{\Delta}_S\) to an expression in terms of \(\delta\).

\begin{defn}
Given
\begin{itemize}
\item classes \(z, \ol{z} \in C\)
\item and trains \(r_1, r_2 \in z\) and \(\ol{r}_1,\ol{r}_2 \in \ol{z}\)
\item with \( d (r_1, r_2) = d(\ol{r}_1, \ol{r}_2) \),
\item then for every \(z \in \rationals\)
\begin{equation}
\label{homoEqLin}
  \delta    (r_1, \ol{r_1}, z) = \delta (r_2, \ol{r_2}, z)\textrm{.}
\end{equation}
\end{itemize}
\end{defn}
\section{Finitizing the integer linear program}
\label{finitizing}

The linear integer program of section \ref{infIP} describes the
problem of finding a homogeneous vehicle schedule.  It uses an
infinite number of variables.  That is hardly tractable.  But we can
reduce the number of variables from infinite to finite.

Equation \ref{matchBedingung} holds for all \(r \in T\) and \(T\) is
already finite.  We declared \(\Delta_S\) to map into \(\rationals^+_0 \cup
\{\infty\}\), but we can restrict the image even further:
\begin{equation}
\label{einfacher}
\Delta_S (s,t) \in \{d (s,t)\} \oplus w \naturals_0
\end{equation}
where \(\oplus\) is the Minkowski sum.
\todo{Proof why \ref{einfacher} (=equation above) holds!}

Thus all \(\delta (s, t, z)\) with \(z \notin \{d (s,t)\} \oplus w
\mathbb{Z}\) vanish.  Furthermore because of the way \(\Delta_S\) is
defined in equation \ref{defDelta} we can bound it from above and below. Call
\begin{equation}
M := \sum_{(r,q) \in T \times T} d (r,q)
\end{equation}
and note
\[0 \leq \Delta_S(s,t) \leq M \textrm{.}\]


Now for every \(s,t \in T\) the relation in an infinite number of
variables described by constraint \ref{onlyOne} can be replaced by the finite:
\begin{align}
  \label{onlyOneFinite}
  \mathop{\sum_{z \in \left\{d (s,t)\right\} \oplus w \naturals_0}}_{z\leq M} \delta(r, q, z) & \leq 1 
\end{align}

A similar transformation turns constraint \ref{zwingRunter} into
\begin{align}
  \label{zwingRunterFinite}
  \sum_{a \in C \times (T \setminus C)} m(a) & \geq \mathop{\sum_{z \in \left\{d (s,t)\right\} \oplus w \naturals_0}}_{z\leq M} \delta (r,q, z) \textrm{.}
\end{align}

To simplify our notation we will introduce
\begin{equation}
\label{defL}
L := \{0, 1, \dots,\left\lceil \frac{M}{w} \right\rceil \}
\end{equation}
and substitue \(D\) for \(\delta\):
\begin{align}
  D \colon & T \times T \times L  \to \{0,1\} \\
          & (s,       t,        n)                              \mapsto \delta (s,t, d(s,t) + n w)
%  D (s,t,n) := 
\end{align}
Now we can rewrite \ref{onlyOneFinite} and \ref{zwingRunterFinite}:
\begin{align}
  \label{onlyOneFiniteN}
  \sum_{n \in L} D (r, q, n) & \leq 1 \\
  \label{zwingRunterFiniteN}
  \sum_{a \in C \times (T \setminus C)} m(a) & \geq \sum_{n \in L} D (r,q, n)
\end{align}

Putting \ref{zwingHoch} into the new form poses bigger
problem. \todo{Warum?  Hier erklärung einfügen.}  For every path \(P
\subseteq \mathbb{S}\) that starts in \(r\) and ends in \(q\) we have:
\[
%\sum_{a \in P} (m(a) - 1) \leq \delta \left(r,q, \sum_{a \in P} d \left(a\right)\right) - 1  \\
%\sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \left[ \sum_{a \in P} d \left(a\right) \right] \right) - 1 \\
\sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \frac{\left(\sum_{a \in P} d \left(a\right)\right) -d(r,q)}{w}\right) - 1  \\
\]
and thus:
\begin{align}
\label{zwingHochFiniteN}
\sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \sum_{a \in P} \frac{ d \left(a\right)}{w} - \frac{d(r,q)}{w}\right) - 1
\end{align}

\todo{Vorher könnten wir n für jeden Bogen unabhäging wählen.  Jetzt
  müssen wir eine Abhängigkeit fordern.  Glücklicherweise können wir das statisch
  bestimmen!
  Was ist die Länge von \(P\) in terms of n in abhängigkeit der
  zwischenschritte?  Und das hat auch geklappt in \ref{zwingHochFiniteN}}

\todo{Formuliere das verendlichte Problem konkret-komplett.  Und füge die eigentliche homogenitätsbedingung hinzu!}

We can express the constraint \ref{homoEqLin} in terms of \(D\), too:
\begin{itemize}
\item Given classes \(z, \ol{z} \in C\)
\item and trains \(r_1, r_2 \in z\) and \(\ol{r}_1,\ol{r}_2 \in \ol{z}\)
\item with \( d (r_1, r_2) = d(\ol{r}_1, \ol{r}_2) \),
\item then for every \(n \in L\)
\begin{equation}
\label{homoEqFin}
  D    (r_1, \ol{r_1}, n) = D (r_2, \ol{r_2}, n)\textrm{.}
\end{equation}
\end{itemize}

\section{Estimating the size of the finite integer linear program}
In section \ref{infIP} we have introduced an integer linear program to
express the problem of homogeneity in vehicle schedulings.  Alas that
program was infinite and thus intractable.  In section
\ref{finitizing} we have finitized the problem.  In theory one could
now feed it into a generic linear program solver and be done with it.

But even the finitized problem suffers from an exuberant size.

How bad is the situation?  The system is made up of binary variables.
There is one variable \(m\) for each arc in the complete graph
\(G_\mathbb{S}\).  So this part takes \(O\left(\left|
    T\right|^2\right)\) variables, where the \(T\) was the number of
service trips.  To model the (possible infinite) length of the path in
\(G_S\) between any two service trips, \(D\) is used.  \(D\) spans
\(O\lr{\abs{T}^2 \abs{L}} =
O\lr{\abs{T}^2 \frac{M}{w}} \) binary variables.  We
take \(w\) to be a constant (usually seven days) and estimate \(M\):
\begin{equation}
M = \sum_{(r,q) \in T \times T} d (r,q) \leq \left|T\right|^2 \max_{(r,q) \in T \times T} d(r,q)
\end{equation}
In practise in Central-Europe trips--- both deadhead and service trips
---are much shorter than half a week.  So we can further estimate:
\begin{equation}
M \leq \left|T\right|^2 w
\end{equation}
Thus \(O\lr{\abs{T}^4}\) variables constitute \(m\), which
dwarves the contribution of \(D\).

\todo{Referenzen zu den relevanten Gleichungen und Namen einführen
  für die O() schätzungen.}

All in all the problem lives in relatively small polynomial number of
binary variables.  However the number of constraints is exponential:

Equations \ref{matchBedingung} describe the conservation of flow.
They take up a modest \(O\lr{\abs{T}}\) rows.  Equations
\ref{onlyOneFiniteN} restrict \(D\) to at most one \(1\)-entry per
pair of service trips, thus ensuring an isomorphism between \(D\) and
\(\ol{\Delta}_S\).  This takes \(O \lr{\abs{T}^2}\) rows.  So far the
number of constraints has been constrained polynomial in \(\abs{T}\).

Equations \ref{zwingRunterFiniteN} come in one version for each cut
\(C \subseteq T\).  Since there are \(O \lr{2^{\abs{T}}}\) cuts, we
need as many rows.  The number of simple paths \(P \subseteq
\mathbb{S}\) that connect every pair of service trips \(r\) and \(q\)
determines the number of rows needed for implementation of constraint
\ref{zwingHochFiniteN}.  It is of equally staggering proportions:
\(O\lr{2^{\abs{T}} \abs{T}!}\) in a lose estimate from above, since
there are \(O\lr{2^{\abs{T}}}\) subsets of service trips that can be
ordered in less than \(O \lr{\abs{T}!}\) ways each.

Taking everything together, we need \(O\lr{\abs{T}^4}\) variables and
\(O\lr{2^{\abs{T}} \abs{T}!}\) constraints.  The next section will
deal with ways to reduce the number of constraints (and incidentally
the number variables, too).

\section{Delayed row generation}
We can start solving with only the equations \ref{matchBedingung} that
guarantee a flow free of sources and sinks and the variables \(m\).
All other variables are treated as parameters set to zero.

We analyse the solutions thus obtained.  The variables \(m\) specify a
graph made of cycles.  For every cycle we can get the distance
\(\Delta\) between all of its nodes by straight-forward counting in
time \(O(T^2)\) \todo{Details zum Zählen.} (or employing Bellman-Ford
etc).  All distances between nodes in different cycles are \(\infty\)
by definition \ref{defDelta}.  \todo{Perhaps use lazy evaluation to
  enumerate all flaws.  Pick the first.}

First check \ref{onlyOne} for every pair of vertices.  If a pair, say
\(s,t\), violates \ref{onlyOne}, let
\begin{equation}
B := \left\{z\leq M \mid
  \delta(r,q,z) = 1\right\} \cap {\left\{d (s,t)\right\} \oplus w
  \naturals_0}
\end{equation} and add
\begin{equation}
  \sum_{z \in B} \delta(r, q, z)  \leq 1
\end{equation}
to the problem.
  
If \ref{onlyOne} holds, \(D\) implies a \(\ol{\Delta_S}\).  Calculate
\(\Delta_S\).  Fix a pair of vertices \(v,w\).  If \(\ol{\Delta_S
  (v,w)} = \Delta_S(v,w)\), do nothing.  Otherwise:
\begin{itemize}
  \item If \(\Delta_S < \infty\), then let \(P\) be the path between \(v\) and \(w\) in \(S\) and add the row
   \begin{equation}
    \sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \sum_{a \in P} \frac{ d \left(a\right)}{w} - \frac{d(r,q)}{w}\right) - 1 \textrm{.}
    \end{equation} 
 \item If \(\Delta_S = \infty\), then let \(C \subseteq S\) be the cycle that includes \(v\) and add:
    \begin{equation}
      \sum_{a \in C \times (T \setminus C)} m(a) \geq \sum_{n \in L} D (r,q, n)
    \end{equation}
    to the problem.
\end{itemize}

\todo{Describe algorithm to find/produce a violated row.  Analyse its
  runtime.  Data structures?}

\todo{Row generation and elimination!  Or more specifically:
  Replacement by stricter constraints.  (Ignore until later.  Just add
  rows as needed.  Cplex will also take care of variables.)}

At the beginning there will be variables that are not present in any
constraint.  A solver like \textsc{Cplex} will only add them to the
problem as the constraints make them have an impact \ie as they show
up with at least one non-zero co\"efficient in at least one constraint
or the objective function.

\subsection{Estimating the runtime of the oracle}

\todo{How fast can we find violated constraints?  I say, fast!  At
  least in polynomial time.  Perhaps even linear?}

\section{Balancing homogeneity with other objectives?}
Homogeneity is a very soft objective, \ie{} its value to Deutsche Bahn
is hard to measure in money.  Partly, the effort invested in achieving
homogeneity is intended to enhance adoption of the other optimizing
work done at department GSU1.

\todo{How about minimal run-times?  NP? Or at least reduce stuff like sorting to the homogeneity problem.}

\section{Implementation}
Implementation will be done in the \textsc{Cplex}-framework existing at
department GSU1 of DB Mobility Logistics AG.
\todo{What happened in the meantime?}

\section{Conclusion}
The framework in use at Deutsche Bahn can handle the addition of homogenity.

\end{document}
