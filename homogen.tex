% Plan: Homomorphismus von Hanno einbauen,
%       Beispiel und Allgemeines in Einleitung trennen.
%       Historie korrigieren (Umlauftage richtig darstellen!)

\documentclass[a4paper]{amsart}
\usepackage{a4}
\usepackage{charter}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{units}
\usepackage{amsmath}
%\usepackage{pdfsync} % does not seem to work currently.

\theoremstyle{definition}
\newtheorem{defn}{Definition}


\author{Matthias Görgens}

% ---- LATIN ----
\def\etal{\emph{et~al.}}
\def\ie{\emph{i.e.}}
\def\eg{\emph{e.g.}}
\def\vitae{vit\ae{}}
\def\apriori{\emph{a~priori}}
\def\aposteriori{\emph{a~posteriori}}

% ---- FRENCH ----
\def\naive{na\"{\i}ve}
\def\Naive{Na\"{\i}ve}
\def\naively{na\"{\i}vely}	% Okay, I know, this isn't French.
\def\Naively{Na\"{\i}vely}


% Other
\def\Cpp{C\raisebox{0.5ex}{\tiny\bf++}}

\newcommand\mpar[1]{\marginpar {\flushleft\sffamily\small #1}}
\setlength{\marginparwidth}{3cm}
\setlength{\marginparpush}{1cm}

\newcommand{\ol}[1]{\overline{#1}}
\newcommand{\todo}[1]{\mpar{#1}}
%\newcommand{\todo}[1]{\footnote{#1}}

\DeclareMathOperator{\In}{in}
\DeclareMathOperator{\Out}{out}

%für ein/aus-gehende kanten
\newcommand{\ina}{\ensuremath{\vec{\In}}}
\newcommand{\outa}{\ensuremath{\vec{\Out}}}

%für knoten ein/aus-gehender kanten.
\newcommand{\inv}{\ensuremath{\dot{\In}}}
\newcommand{\outv}{\ensuremath{\dot{\Out}}}

\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
% lr := left right
\newcommand{\lr}[1]{\ensuremath{\left( #1 \right)}}
% lrM := left right fuer Mengen
\newcommand{\lrM}[1]{\ensuremath{\left\{ #1 \right\}}}


\usepackage{hyperref}
\begin{document}

\date{\today}
\title{Homogeneous vehicle schedules}

\begin{abstract}
  Although most railroad timetables remain in use for half a
  year, they tend to repeat themself each week.  Thus one can also
  repeat their implementations in rolling stock, the vehicle
  schedulings, each week.

  But timetables show even more structure: All the working days of the
  week are usually identical.  This work sets out to investigate how
  to preserve this similarity in vehicle schedulings.  We define
  homogeneous vehicle schedulings, establish a measure of partial
  homogeneity and search for ways to efficiently find the most
  homogeneous vehicle scheduling for a given timetable.
\end{abstract}

\maketitle
\todo{unterschied zwischen fahrplan und umlaufplan im abstract ausarbeiten.}
\todo{Mit Hanno besprochen: 
  - darstellung der legacy anwendung (blockdarstellung:
  di,mi,do als einen tag planen, ausnahmen einfuegen, rest der woche einfuegen)
  - Morphism between torus (=tagesplaene) und umlaufkettendarstellung.
  und aufweichen der homogen.-bedingung durch trennen von zuegen.
  - herleitung der homogenitaetsbedingung
}

\section{Introduction}
Unlike individual traffic in cars, railroads in Germany are run by
only a few companies and of those Deutsche Bahn controls a huge
majority.  In principle the planning required can be centralized for
coordination.  Thus one can exploit effects of synergy.  Even
relatively modest relative improvements can have a huge absolute
impact.  So it is worthwhile to solve the encountered problems to
optimality.

One large block---or even the largest---of opportunities for
mathematical planning in this contexts lies in the area of scheduling.
Currently at Deutsche Bahn the system for planning schedules is
multi-tiered.  This paper has been written while working at department
GSU1 of DB Mobility Logistics.  The focus at GSU1 is on
improving the process of (strategic) vehicle schedulings.

As a passenger one only interfaces with the timetables, that specify
when and where a train will arrive and depart.  One does not care too
much which specific physicial train one is using or what it does
before and after the trip.

\todo{Ein abregenzendes Wort zu timetable und operationeller Plannung
  im Vergleich.}

Naturally the railroad  It has to re-use them.  Various costs have to be
taken into account.  Introducing our first bit of notation we call
trips offered to the customer \textit{service trips} (or Nutzfahrten
in German) and other trips will be called \textit{deadhead trips}
(Leerfahrten in German).  Deadhead trips may be necessary because a
station may have an unequal number of service trips departing and
arriving over the course of a week.  Or the number is equal, and the
station could keep the balance in theory, but only with long
unproductive standing times for the trains.

The most important objective concerns the minimization of the number
of trains needed to honour all required service trips in the
timetable.  Avoiding deadhead trips ranks second.  They cost man-hours,
fuel, and bring the next obligatory maintenance closer.  Most types of
maintenance are scheduled every time a train has travelled a certain
distance.

Most timetables are in use for half a year.  They tend to repeat every
week.  At the current state of the art, strategic vehicle schedule
planning ignores the start and end of the period and pretends to work
on an infinite cycle of identical weeks.  This allows to collapse an
infite linear model of time to a cycle of just one week.

Strategic vehicle schedule planning in essence takes in cyclic
timetables (plus possible non-cyclic extra trips) and puts out vehicle
schedules to the operational planners, who \eg{} manage the transition
between schedules.

Deutsche Bahn has only recently brought sophisticated math to bear on
these issues.  There are legacy heuristics in place that solved (and
do solve) scheduling, but with no guarantees of optimality.  Also
customs and preferences have developed.

For example planners prefer their schedule to be as homogenous as
possible.  \todo{Why?} In former times the days have been planned as
blocks and only later have the individual plans been fused.

The new methods based on mixed integer programming consider the whole
week right from the start.  Apart from the partly repeating schedule
they have no cause to use similar vehicle schedulings on the working
days.  But planners have come to price the homogeneity as an end in
itself, because their preferred visualization of schedules
looks more pleasing in the presence of homogeneity.
\todo{Add more about blocks. Visualization.}

\todo{Noch mehr Grundlagen.  Ausfuehrungen zu Betriebsablauf bei der Bahn.}

\section{Thanks}
Thanks to Hanno Schülldorf, Volker Kaibel and Andreas Huck for their
help.
\todo{Noch ein paar mehr Leute auffuehren.}

\section{Some definitions}

\todo{Noch mehr mathematische Grundlagen?  Column and Row generation?}

Let \(G=(V,A)\) be a digraph of connected stations, \eg{} ordinary
railway stations, maintenance shops.  Now look at \label{trains}
\textit{trains} \((v, t_v, w, t_w) \in \left(V \times
  \mathbb{Q}\right)^2 \) where \(v\), \(t_v\) name the station and
time of departure, and \(w\), \(t_v\) name the station and time of
arrival.  We call a set of trains \(T \subseteq \left(V \times
  \mathbb{Q}\right)^2\) a timetable.  (In practise \(T\) can also be a
multiset.)

We want to focus our attention to cyclic timetables.
\begin{defn} A timetable \(T\) is \label{cyclic} \textit{cyclic}, iff
  there exists a period \(w \in \mathbb{Q}^+\), so that for each train
  \((v, t_v, w, t_w) \in T\) the trains \(\{(v, t_v+n w, w, t_w +n w)
  \mid n \in \mathbb{Z}\}\) are also in \(T\).
\end{defn}
We will identify cyclic timetables with their image under the canonic
morphism \(\varphi \colon \left(V \times \mathbb{Q}\right)^2 \to
\left(V \times \mathbb{Q}/{\left(w \mathbb{Z}\right)}\right)^2\).

A timetable only fixes the services offered by the railroad company.
But it does not specify where the locomotives and waggons in use come
from or where they go afterwards.  Naturally one wants to re-use
rolling stock from one train for another one.  So one seeks to
establish a digraph \(G_S=(T,S\subseteq T^2)\), where each train has
exactly one predecessor and exactly one successor.  Thus \(G_s\)
consists of cycles.

\todo{motivation.  warum keine einfacheren ansätze?}

In practise timetables repeat every week \ie{} \(w = 7 \textrm{ days}\).
This work will deal with timetables that show more structure: Fix an
interval \(d := \frac{w}{n}\) with \(n \in \mathbb{N}^+\) (\eg{} for
days in a week, let \(n=7\)).  We partition the trains into
equivalence classes that share the same arrival and departure
stations, and whose arrival and departure times only differ by an
integral multiply of \(w\) (\ie{} whole days):
\begin{equation}
  \left[\left( v, t_v, w, t_w \right) \right]_d := \{(v, t_v+n d, w, t_w +n d) \mid n \in \mathbb{Z}\}
\end{equation}
Let \(C\) be the set of all those classes.

Ideally each class has exactly one member for each day of the week.
That would allow \(w = 1 \textrm{ day}\) instead of \(w = 7 \textrm{ days}\)
and enable a schedule that repeats perfectly every day.  But more
typical we observe a lot of classes in a timetable with one member
each day from Monday to Friday and none on the weekends.  Or even less
regular arrangements.

We will define a distance function \(\Delta_S (s,t)\) on paths in
\(S\) as the sum of arc lengths \(d\) in the path between the
trains \(s\) and \(t\) or \(\infty\) if no such path exists.  We can
talk about \emph{the} path \(P \subseteq S\) between \(s\) and \(t\),
because \(G_S\) consists only of disjoint cycles.
\[\Delta_{S}\colon T \times T \to \mathbb{Q}^+_0 \cup \{\infty\}\]
\begin{equation}
\label{defDelta}
\Delta_S (s,t) = \begin{cases}
\sum_{(v,w)\in P} d(v,w) & \textrm{if there is a path \( P \in S\) between \(s\) and \(t\)}\\
\infty & \textrm{else}
\end{cases}
\end{equation}

\todo{Bezeichnungen!  Pfeile über t?}

\todo{Mehrwöchige Fahrten:  Zurückgehen auf die ursprüngliche nicht-zyklische Version!}

Of course we have only moved the problem.  We still have to define the length of a single arc:  \(d(t, \ol{t})\) shall be the minimal time that a vehicle needs to provide \(t\) and be ready for the departure of \(\ol{t}\):
\[
d ((\cdot, t_{\textrm{dep}}, \cdot, t_{\textrm{arr}}), (\cdot, \ol{t_{\textrm{dep}}},\cdot, \cdot)  :=
\min (\{\ol{t_{\textrm{dep}}} - t_{\textrm{dep}} + n w \mid \ol{t_{\textrm{dep}}} - t_{\textrm{arr}} + nw \geq 0, n \in \mathbb{Z}\} \cap \mathbb{Q}^+_0)
\]

In most cases this will be just the difference \(\ol{t_{\textrm{dep}}}
- t_{\textrm{dep}}\), but we may need to add a whole number of weeks
if \(\ol{t}\) departs before \{t\} arrives.  Also a more general approach
has to be taken when trains take more than one week from arrival to
departure.

To guarantee homogeneity one might \naively{} propose that all members
of one class \(c_1\) only be succeeded by members of the same class
\(c_2\).  But that would not be practial, because \eg{} a class that is
offered all week would be banned from being connected to a class of trains that
are not offered on the weekend.

\todo{motivation.  faellt aus der luft.. zitat der begriffsbestimmung.}
So we introduce a weaker condition.  A schedule \(S\) is called
homogenous iff:
\begin{defn} Given
  \begin{itemize}
  \item classes \(z, \ol{z} \in C\)
  \item and trains \(r_1, r_2 \in z\) and \(\ol{r}_1,\ol{r}_2 \in \ol{z}\)
  \item with \( d (r_1, r_2) = d(\ol{r}_1, \ol{r}_2) \),
\end{itemize}
  then either there is no path between neither \(r_1\) and
    \(\ol{r}_2\) nor \(r_2\) and \(\ol{r}_2\) in \(S\); or they are connected by paths of the same length:
    \begin{equation}
      \label{homoEq}
      \Delta_S (r_1, \ol{r_1}) = \Delta_S (r_2, \ol{r_2})\textrm{.}
    \end{equation}
\end{defn}


\todo{motivation fuer definition}
\begin{defn}
For arcs in a digraph \(G=(V,A)\) we will use the following notation:
\begin{align*}
\ina\colon  V &\to \mathcal{P}(A) \\
v &\mapsto \left(V \times \{v\}\right) \cap A\\
%\end{align*}
%\begin{align*}
\outa\colon  V &\to \mathcal{P}(A) \\
v &\mapsto \left(\{v\} \times V\right) \cap A\\
%\end{align*}
%\begin{align*}
\inv\colon  V &\to \mathcal{P}(V) \\
v &\mapsto \left\{ u \colon \left(u,v\right) \in \ina(v) \right\}\\
%\end{align*}
%\begin{align*}
\outv\colon  V &\to \mathcal{P}(V) \\
v &\mapsto \left\{w \colon \left(v,w\right) \in \outa\left(v\right) \right\}\\
\end{align*}
\end{defn}

\section{An infinite integer linear program}
\label{infIP}

Let \(T\) be a timetable.  And let \(G_\mathbb{S} := (T, \mathbb{S} =
T \times T) \) be its associated complete graph.  A schedule \(G_S =
(T, S \subseteq \mathbb{S})\) will be a subgraph of \(G_\mathbb{S}\).


For the integer program we introduce the variable \(m\) with the
following domain and interpretation:
\begin{align}
  m & \colon T \times T \to \{0,1\} \\
  m & \cong \mathbf{1}_{S}
\end{align}
Where \(\cong\) means ``defined as'' or ``to be interpreted as''.

The following two equations capture the requirement that \(G_S\)
consists of disjoint cycles.  For all \(r \in T\):
\begin{align}
  \label{matchBedingung}
  \sum_{a \in \ina(r)}  m(a) = \sum_{a \in \outa(r)} m(a) = 1
\end{align}

To reflect the values of \(\Delta_S\) in the integer program we use the binary variables \(\delta\):
\begin{align}
  \delta \colon T \times T \times \mathbb{Q} & \to \{0,1\} \\
  \delta\left(r, q, \Delta_S\left(r,q\right)\right) &\cong 1 \\
  \label{onlyOne}
  \sum_{z \in \mathbb{Q}} \delta(r, q, z) &\leq 1
\end{align}

For every simple path \(P \subseteq \mathbb{S}\) that starts in \(r\) and ends in \(q\) we have:
\begin{align}
\label{zwingHoch}
\sum_{a \in P} (m(a) - 1) \leq \delta \left(r,q, \sum_{a \in P} d \left(a\right)\right) - 1 \textrm{;}
\end{align}
\ie{} if \(P \subseteq S\) then length of \(P\) gives
the distance between its endpoints in \(S\).

And for every \(r\)-\(q\)-cut \(C \subseteq T\) (with \(r \in C\)):
\begin{align}
\label{zwingRunter}
  \sum_{a \in C \times (T \setminus C)} m(a) \geq \sum_{z \in \mathbb{Q}} \delta (r,q, z)
\end{align}

% \(G_S=(T,S\subseteq T^2)\)


% Aufbau: Modell oder Anwendung?
% Anwendung: Umlaufplanung etc, Abschätzung anderer Möglichkeiten.  Anwendung zur Motivation.
% Welcher Umfang zur Anwendung?  Literatur.  Allgemeine Beschreibung?  Irgendeine Referenz wird es schon geben.

% relation durch Übersetzung von Nutzfahrt ersetzen.

\todo{welche constraints?  labels und refs.  convex set vs gitterpunkte?}
Those constraints define a convex set.  Alas we can't use them
directly, since there are an infinite number of constraints.  But
fortunately they are constructed for use with row generation.  We will
show that there is a finite subset of constraints that define the same
polytope.  And we will show how to define a polynomial oracle to find
violated constraints.

Now we only have defined a way to measure time-distances in the
vehicle schedule in a linear integer program.  We still have to
incorporate the actual homogeneity constraints laid out in equation
\ref{homoEq}.  But this is simple as we only have to convert
\ref{homoEq} from using \(\ol{\Delta}_S\) to an expression in terms of \(\delta\).

\begin{defn}
Given
\begin{itemize}
\item classes \(z, \ol{z} \in C\)
\item and trains \(r_1, r_2 \in z\) and \(\ol{r}_1,\ol{r}_2 \in \ol{z}\)
\item with \( d (r_1, r_2) = d(\ol{r}_1, \ol{r}_2) \),
\item then for every \(z \in \mathbb{Q}\)
\begin{equation}
\label{homoEqLin}
  \delta    (r_1, \ol{r_1}, z) = \delta (r_2, \ol{r_2}, z)\textrm{.}
\end{equation}
\end{itemize}
\end{defn}
\section{Finitizing the integer linear program}
\label{finitizing}
\todo{Motivation!}

The linear integer program of section \ref{infIP} describes the
problem of finding a homogeneous vehicle schedule.  It uses an
infinite number of variables.  That is hardly tractable.  But we can
reduce the number of variables from infinite to finite.

Equation \ref{matchBedingung} holds for all \(r \in T\) and \(T\) is
already finite.  We declared \(\Delta_S\) to map into \(\mathbb{Q}^+_0 \cup
\{\infty\}\), but we can restrict the image even further:
\begin{equation}
\label{einfacher}
\Delta_S (s,t) \in \{d (s,t)\} \oplus w \mathbb{N}_0
\end{equation}
where \(\oplus\) is the Minkowski sum.
\todo{Proof why \ref{einfacher} (=equation above) holds!}

Thus all \(\delta (s, t, z)\) with \(z \notin \{d (s,t)\} \oplus w
\mathbb{Z}\) vanish.  Furthermore because of the way \(\Delta_S\) is
defined in \ref{defDelta} we can bound it from above and below. Call
\begin{equation}
M := \sum_{(r,q) \in T \times T} d (r,q)
\end{equation}
and note
\[0 \leq \Delta_S(s,t) \leq M \textrm{.}\]


Now for every \(s,t \in T\) the equations in an infinite number of
variables described by \ref{onlyOne} can be replaced by the finite:
\begin{align}
  \label{onlyOneFinite}
  \mathop{\sum_{z \in \left\{d (s,t)\right\} \oplus w \mathbb{N}_0}}_{z\leq M} \delta(r, q, z) & \leq 1 
\end{align}

A similar transformation turns constraint \ref{zwingRunter} into
\begin{align}
  \label{zwingRunterFinite}
  \sum_{a \in C \times (T \setminus C)} m(a) & \geq \mathop{\sum_{z \in \left\{d (s,t)\right\} \oplus w \mathbb{N}_0}}_{z\leq M} \delta (r,q, z) \textrm{.}
\end{align}

To simplify our notation we will introduce
\begin{equation}
\label{defL}
L := \{0, 1, \dots,\left\lceil \frac{M}{w} \right\rceil \}
\end{equation}
and substitue \(D\) for \(\delta\):
\begin{align}
  D \colon & T \times T \times L  \to \{0,1\} \\
          & (s,       t,        n)                              \mapsto \delta (s,t, d(s,t) + n w)
%  D (s,t,n) := 
\end{align}
Now we can rewrite \ref{onlyOneFinite} and \ref{zwingRunterFinite}:
\begin{align}
  \label{onlyOneFiniteN}
  \sum_{n \in L} D (r, q, n) & \leq 1 \\
  \label{zwingRunterFiniteN}
  \sum_{a \in C \times (T \setminus C)} m(a) & \geq \sum_{n \in L} D (r,q, n)
\end{align}

Putting \ref{zwingHoch} into the new form poses bigger
problem. \todo{Warum?  Hier erklaerung einfuegen.}  For every path \(P
\subseteq \mathbb{S}\) that starts in \(r\) and ends in \(q\) we have:
\[
%\sum_{a \in P} (m(a) - 1) \leq \delta \left(r,q, \sum_{a \in P} d \left(a\right)\right) - 1  \\
%\sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \left[ \sum_{a \in P} d \left(a\right) \right] \right) - 1 \\
\sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \frac{\left(\sum_{a \in P} d \left(a\right)\right) -d(r,q)}{w}\right) - 1  \\
\]
and thus:
\begin{align}
\label{zwingHochFiniteN}
\sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \sum_{a \in P} \frac{ d \left(a\right)}{w} - \frac{d(r,q)}{w}\right) - 1
\end{align}

\todo{Vorher koennten wir n fuer jeden Bogen unabhaeging waehlen.  Jetzt
  muessen wir eine Abhaengigkeit fordern.  Gluecklicherweise koennen wir das statisch
  bestimmen!

  Was ist die Laenge von \(P\) in terms of n in abhaengigkeit der
  zwischenschritte?  Und das hat auch geklappt in \ref{zwingHochFiniteN}}

\todo{Formuliere das verendlichte Problem konkret-komplett.  Und fuege die eigentliche homogenitaetsbedingung hinzu!}

We can express the constraint \ref{homoEqLin} in terms of \(D\), too:
\begin{itemize}
\item Given classes \(z, \ol{z} \in C\)
\item and trains \(r_1, r_2 \in z\) and \(\ol{r}_1,\ol{r}_2 \in \ol{z}\)
\item with \( d (r_1, r_2) = d(\ol{r}_1, \ol{r}_2) \),
\item then for every \(n \in L\)
\begin{equation}
\label{homoEqFin}
  D    (r_1, \ol{r_1}, n) = D (r_2, \ol{r_2}, n)\textrm{.}
\end{equation}
\end{itemize}

\section{Estimating the size of the finite integer linear program}
In section \ref{infIP} we have introduced an integer linear program to
express the problem of homogeneity in vehicle schedulings.  Alas that
program was infinite and thus intractable.  In section
\ref{finitizing} we have finitized the problem.  In theory one could
now feed it into a generic linear program solver and be done with it.

But even the finitized problem suffers from an exuberant size.

How bad is the situation?  The system is made up of binary variables.
There is one variable \(m\) for each arc in the complete graph
\(G_\mathbb{S}\).  So this part takes \(O\left(\left|
    T\right|^2\right)\) variables, where the \(T\) was the number of
service trips.  To model the (possible infinite) length of the path in
\(G_S\) between any two service trips, \(D\) is used.  \(D\) spans
\(O\lr{\abs{T}^2 \abs{L}} =
O\lr{\abs{T}^2 \frac{M}{w}} \) binary variables.  We
take \(w\) to be a constant (usually seven days) and estimate \(M\):
\begin{equation}
M = \sum_{(r,q) \in T \times T} d (r,q) \leq \left|T\right|^2 \max_{(r,q) \in T \times T} d(r,q)
\end{equation}
In practise in Central-Europe trips--- both deadhead and service trips
---are much shorter than half a week.  So we can further estimate:
\begin{equation}
M \leq \left|T\right|^2 w
\end{equation}
Thus \(O\lr{\abs{T}^4}\) variables constitute \(m\), which
dwarves the contribution of \(D\).

\todo{Referenzen zu den relevanten Gleichungen und Namen einfuehren
  fuer die O() schaetzungen.}

All in all the problem lives in relatively small polynomial number of
binary variables.  However the number of constraints is exponential:

Equations \ref{matchBedingung} describe the conservation of flow.
They take up a modest \(O\lr{\abs{T}}\) rows.  Equations
\ref{onlyOneFiniteN} restrict \(D\) to at most one \(1\)-entry per
pair of service trips, thus ensuring an isomorphism between \(D\) and
\(\ol{\Delta}_S\).  This takes \(O \lr{\abs{T}^2}\) rows.  So far the
number of constraints has been constrained polynomial in \(\abs{T}\).

Equations \ref{zwingRunterFiniteN} come in one version for each cut
\(C \subseteq T\).  Since there are \(O \lr{2^{\abs{T}}}\) cuts, we
need as many rows.  The number of simple paths \(P \subseteq
\mathbb{S}\) that connect every pair of service trips \(r\) and \(q\)
determines the number of rows needed for implementation of constraint
\ref{zwingHochFiniteN}.  It is of equally staggering proportions:
\(O\lr{2^{\abs{T}} \abs{T}!}\) in a lose estimate from above, since
there are \(O\lr{2^{\abs{T}}}\) subsets of service trips that can be
ordered in less than \(O \lr{\abs{T}!}\) ways each.

Taking everything together, we need \(O\lr{\abs{T}^4}\) variables and
\(O\lr{2^{\abs{T}} \abs{T}!}\) constraints.  The next section will
deal with ways to reduce the number of constraints (and incidentally
the number variables, too).

\section{Delayed row generation}
We can start solving with only the equations \ref{matchBedingung} that
guarantee a flow free of sources and sinks and the variables \(m\).
All other variables are treated as parameters set to zero.

We analyse the solutions obtained.  The variables \(m\) specify a
graph made of cycles.  For every cycle we can get the distance
\(\Delta\) between all of its nodes by straight-forward counting in
time \(O(T^2)\) \todo{Details zum Zaehlen.} (or employing Bellman-Ford
etc).  All distances between nodes in different cycles are \(\infty\)
by definition \ref{defDelta}.  \todo{Perhaps use lazy evaluation to enumerate
  all flaws.  Pick the first.}

First check \ref{onlyOne} for every pair of vertices.  If a pair, say
\(s,t\), violates \ref{onlyOne}, let 
\begin{equation}
B := \left\{z\leq M \mid
  \delta(r,q,z) = 1\right\} \cap {\left\{d (s,t)\right\} \oplus w
  \mathbb{N}_0}
\end{equation} and add
\begin{equation}
  \sum_{z \in B} \delta(r, q, z)  \leq 1
\end{equation}
to the problem.
  
If \ref{onlyOne} holds, \(D\) implies a \(\ol{\Delta_S}\).  Calculate
\(\Delta_S\).  Fix a pair of vertices \(v,w\).  If \(\ol{\Delta_S
  (v,w)} = \Delta_S(v,w)\), do nothing.  Otherwise:
\begin{itemize}
  \item If \(\Delta_S < \infty\), then let \(P\) be the path between \(v\) and \(w\) in \(S\) and add the row
   \begin{equation}
    \sum_{a \in P} (m(a) - 1) \leq D \left(r,q, \sum_{a \in P} \frac{ d \left(a\right)}{w} - \frac{d(r,q)}{w}\right) - 1 \textrm{.}
    \end{equation} 
 \item If \(\Delta_S = \infty\), then let \(C \subseteq S\) be the cycle that includes \(v\) and add:
    \begin{equation}
      \sum_{a \in C \times (T \setminus C)} m(a) \geq \sum_{n \in L} D (r,q, n)
    \end{equation}
    to the problem.
\end{itemize}

\todo{Describe algorithm to find/produce a violated row.  Analyse its
  runtime.  Data structures?}

\todo{Row generation and elimination!  Or more specifically:
  Replacement by stricter constraints.  (Ignore until later.  Just add
  rows as needed.  Cplex will also take care of variables.)}

At the beginning there will be variables that are not present in any
constraint.  A solver like \textsc{Cplex} will only add them to the
problem as the constraints make them have an impact \ie as they show
up with at least one non-zero coefficient in at least one constraint
or the objective function.

\subsection{Estimating the runtime of the oracle}

\todo{How fast can we find violated constraints?  I say, fast!  At
  least in polynomial time.  Perhaps even linear?}

\section{Balancing homogeneity with other objectives?}
Homogeneity is a very soft objective, \ie its value is hard to measure
in money.  Partly, the effort invested in achieving homogeneity is
intended to enhance adoption of the other optimizing work done at
department \textsc{Gsu1}.

\section{Implementation}
Implementation will be done in the \textsc{Cplex}-framework existing at
department GSU1 of DB Mobility Logistics AG.
\section{Conclusion}

\end{document}
